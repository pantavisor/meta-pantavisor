# pv-efi-boot — Pantavisor EFI Boot Loader

## Status

**Working implementation.** The full EFI boot chain boots to pantavisor READY state
in QEMU with OVMF. Containers start, pvcontrol and pventer work. See `TESTPLAN-EFI.md`
for executable tests.

### What works

- Stage 1 + stage 2 EFI boot chain (gnu-efi, ~150 lines each)
- autoboot.txt parsing with `[all]`/`[tryboot]` sections
- UKI assembly via objcopy (kernel + initramfs + cmdline)
- WIC image with GPT: ESP + boot_a + boot_b + pvdata
- Pantavisor efiab bootloader (`PV_BOOTLOADER_TYPE=efiab`)
- efivarfs mounted, standard EFI variables accessible
- autoboot.txt read/write via mtools (mcopy)
- Containers (os, pvr-sdk) reach STARTED state
- pvcontrol, pvcurl, pventer all operational
- QEMU automation via expect scripts

### Not yet implemented

- EFI variable communication (PvTryBoot, PvBootPartition, PvBootTryBoot)
  — stage1 currently hardcodes boot_partition from autoboot.txt only
- Tryboot one-shot cycle (set PvTryBoot, reboot, stage1 reads+deletes)
- A/B update install and commit (efiab.c stubs exist but untested)
- Secure Boot signing
- TPM measurements

## Overview

A two-stage UEFI boot loader for Pantavisor on x86 systems, implementing
A/B boot partition switching using the exact same `autoboot.txt` syntax as
Raspberry Pi's tryboot mechanism. Kernels are delivered as Unified Kernel
Images (UKI) which bundle kernel, initramfs, and command line into a single
signed and measured PE/COFF binary.

- **Stage 1** — minimal EFI app on the ESP (`EFI/BOOT/BOOTX64.EFI`). Reads
  `autoboot.txt`, handles one-shot tryboot via EFI variable, chainloads stage 2.
  Never updated.
- **Stage 2** — lives on the active boot partition (`pvboot.efi`). Loads
  the UKI. Updateable as part of A/B slot updates.
- **UKI** — single signed PE/COFF binary (`pv-linux.efi`) containing kernel +
  initramfs + cmdline. No loose config files. Everything verified by Secure Boot
  and measured into TPM.

All filesystems are FAT32. No ext4 support needed. Pure gnu-efi, no external
libraries. Trivial Yocto recipe. All dependencies available in oe-core
scarthgap.

## Partition Layout

Works with both MBR and GPT partition tables. UEFI firmware abstracts partition
discovery via the Hard Drive Device Path node, which numbers partitions starting
at 1 for both MBR and GPT.

Current implementation uses GPT:

```
Partition table (GPT):

  Partition 1:  esp            (FAT32, 64MB, EFI System type)
                  └─ EFI/BOOT/BOOTX64.EFI  (stage 1)
                  └─ autoboot.txt

  Partition 2:  boot_a         (FAT32, 128MB)
                  └─ pvboot.efi            (stage 2)
                  └─ pv-linux.efi          (UKI: kernel + initrd + cmdline)

  Partition 3:  boot_b         (FAT32, 128MB)
                  └─ pvboot.efi            (stage 2, copy)
                  └─ pv-linux.efi          (UKI, copy)

  Partition 4:  pvdata         (ext4, ~2.6GB)
                  └─ Pantavisor state, containers, volumes
```

Defined in: `wic/pantavisor-efi.wks`
Verify: `fdisk -l build/tmp-scarthgap/deploy/images/x64-efi/pantavisor-remix-x64-efi.rootfs.wic`

### MBR notes
- Partition types: 0xEF for ESP, 0x0C for boot partitions
- Maximum 4 primary partitions works fine for this layout
- Some UEFI firmware requires CSM or explicit MBR EFI support — test matrix
  needed

### GPT notes
- ESP uses standard EFI System Partition type GUID
  (C12A7328-F81F-11D2-BA4B-00A0C93EC93B)
- Boot partitions use Microsoft Basic Data GUID or a custom Pantavisor GUID
- Partition labels (pvboot-a, pvboot-b) available as additional discovery hint
  but not relied upon — partition number is primary key

## Key Files

### Yocto recipes

| File | Purpose |
|------|---------|
| `conf/machine/x64-efi.conf` | Machine: core2-64 tune, EFI features, OVMF, QEMU settings |
| `kas/machines/x64-efi.yaml` | KAS config: machine + platform includes |
| `kas/platforms/x86-efi.yaml` | Platform: EFI distro features, kernel config |
| `.github/configs/release/x64-efi-scarthgap.yaml` | Release config (auto-generated by makemachines) |
| `recipes-bsp/pv-efi-boot/pv-efi-boot_1.0.bb` | Stage 1 + stage 2 EFI binaries (gnu-efi) |
| `recipes-bsp/pv-efi-boot/efi-esp-image.bb` | ESP partition image (stage1 + autoboot.txt) |
| `recipes-bsp/pv-efi-boot/efi-boot-image.bb` | Boot partition image (stage2 + UKI) |
| `recipes-bsp/pv-uki/pv-uki_1.0.bb` | UKI assembly (objcopy: kernel + initramfs + cmdline) |
| `recipes-bsp/pv-uki/files/cmdline.txt` | Kernel command line baked into UKI |
| `recipes-kernel/linux/files/efi.cfg` | Kernel EFI config fragment |
| `wic/pantavisor-efi.wks` | WIC disk layout (ESP + boot_a + boot_b + pvdata) |

### Pantavisor source (workspace)

| File | Purpose |
|------|---------|
| `build/workspace/sources/pantavisor/efiab.c` | EFI A/B bootloader ops (~700 lines) |
| `build/workspace/sources/pantavisor/config.h` | `BL_EFIAB` enum value |
| `build/workspace/sources/pantavisor/config.c` | "efiab" string parsing |
| `build/workspace/sources/pantavisor/bootloader.c` | `efiab_ops` dispatch |
| `build/workspace/sources/pantavisor/state.h` | `efiab` BSP image union member |
| `build/workspace/sources/pantavisor/paths.h` | `EFIABTXT_FNAME` define |
| `build/workspace/sources/pantavisor/parser/parser_system1.c` | "efiab" BSP key |

### Scripts

| File | Purpose |
|------|---------|
| `scripts/run-qemu-efi.sh` | Interactive QEMU boot (Ctrl-A X to quit) |
| `scripts/qemu-diag.exp` | Automated boot + diagnostics via expect |
| `scripts/test-update-efi.exp` | EFI A/B update cycle test (pvcontrol + reboot) |

## Unified Kernel Image (UKI)

A UKI is a PE/COFF executable that bundles everything needed to boot into
a single file. It uses the Linux EFI stub as the entry point and embeds
kernel, initramfs, and cmdline as PE sections.

Built by `pv-uki_1.0.bb` using objcopy with the kernel's EFI stub:

```
pv-linux.efi (PE/COFF):
  .cmdline  → "root=/dev/sda4 ro console=ttyS0,115200 PV_BOOTLOADER_TYPE=efiab ..."
  .linux    → bzImage (kernel)
  .initrd   → pantavisor-initramfs (cpio.gz)
```

The EFI stub is extracted from the kernel build at:
`${STAGING_DIR}/.../linux/arch/x86/boot/compressed/vmlinux.bin` →
objcopy strips and rebases sections onto `linuxx64.efi.stub`.

Current cmdline (`recipes-bsp/pv-uki/files/cmdline.txt`):
```
root=/dev/sda4 ro console=ttyS0,115200 PV_BOOTLOADER_TYPE=efiab PV_LOG_SERVER_OUTPUTS=filetree
```

### Why UKI

- **Single signed artifact**: `LoadImage()` verifies the entire binary including
  the embedded cmdline — no unsigned config files on disk
- **Single TPM measurement**: PCR 4 gets one extend for the whole boot payload
- **Simplifies stage 2**: No cmdline parsing, no LOAD_FILE2_PROTOCOL for initrd,
  just `LoadImage` + `StartImage`
- **Standard tooling**: Built with `ukify` (systemd) or raw `objcopy`

### Building UKIs

```bash
# Option 1: ukify (systemd tool, available in oe-core scarthgap)
ukify build \
  --linux vmlinuz \
  --initrd initramfs.img \
  --cmdline "root=/dev/dm-0 ro quiet" \
  --output pv-linux.efi

# Option 2: objcopy (no systemd dependency, minimal approach — current implementation)
objcopy \
  --add-section .cmdline=cmdline.txt --change-section-vma .cmdline=0x30000 \
  --add-section .linux=vmlinuz --change-section-vma .linux=0x2000000 \
  --add-section .initrd=initramfs.img --change-section-vma .initrd=0x3000000 \
  /usr/lib/systemd/boot/efi/linuxx64.efi.stub \
  pv-linux.efi

# Sign the UKI
sbsign --key db.key --cert db.crt --output pv-linux-signed.efi pv-linux.efi
```

### UKI cmdline considerations

The kernel command line is baked into the UKI at build time. For Pantavisor
this is fine because:

- `root=` points to the data partition (fixed, same for both slots)
- Slot-specific info (which partition booted, tryboot status) is passed via
  volatile EFI variables, not cmdline
- Any per-device configuration lives in the Pantavisor data partition, not
  boot parameters

If per-slot cmdline differences are ever needed, build separate UKIs per slot
(which you're doing anyway since they're on separate partitions).

## autoboot.txt

Lives at root of ESP (`/dev/sda1`): `/autoboot.txt`

Uses the **exact same syntax** as Raspberry Pi autoboot.txt:

```ini
[all]
tryboot_a_b=1
boot_partition=2

[tryboot]
boot_partition=3
```

### Semantics

| Section     | When used                               |
|-------------|-----------------------------------------|
| `[all]`     | Always parsed                           |
| `[tryboot]` | Only when tryboot flag is active; values override `[all]` |

| Key              | Description                                          |
|------------------|------------------------------------------------------|
| `tryboot_a_b`    | Set to `1` to enable A/B partition-level tryboot      |
| `boot_partition` | Partition number to boot from (1-based, matches both MBR and GPT numbering) |

Identical syntax to Raspberry Pi autoboot.txt. Read by stage 1 to determine
which boot partition to chainload. Read by pantavisor efiab.c via `mcopy`
for A/B state tracking.

### Atomicity

The file must stay under 512 bytes (one disk sector). A single-sector write
is atomic at the hardware level per ATA and NVMe specs. Since `autoboot.txt`
is ~60 bytes, overwrites are always atomic. No rename dance needed.

### Flip procedure from Linux

```bash
# After successful boot on new slot, commit by flipping autoboot.txt
# (assumes slot B = partition 3 is now the good one)
mount /dev/sda1 /mnt/esp
cat > /mnt/esp/autoboot.txt << 'EOF'
[all]
tryboot_a_b=1
boot_partition=3

[tryboot]
boot_partition=2
EOF
umount /mnt/esp
```

Note: after flipping, `[all]` points to the newly committed slot and
`[tryboot]` points to the other slot (which becomes the next try target).
This matches RPi convention.

## EFI Variables

All use vendor GUID `{a4e3e45c-b87f-4a56-9078-5f4e3a2d1c8b}`.

Currently stage 1 does not set PvBootPartition/PvBootTryBoot variables — it reads
autoboot.txt directly. The efiab.c init falls back gracefully when variables are absent.

### PvTryBoot (non-volatile, one-shot)

Equivalent of RPi's tryboot mailbox flag / `reboot "0 tryboot"`.

- **Name:** `PvTryBoot`
- **Attributes:** `NV | BS_ACCESS | RT_ACCESS`
- **Value:** single byte, `0x01` = tryboot requested
- **Semantics:** Stage 1 reads it. If set, deletes it immediately (one-shot),
  then uses the `[tryboot]` section of autoboot.txt to determine boot_partition.

Setting from Linux (equivalent of `reboot "0 tryboot"` on RPi):

```bash
GUID="a4e3e45c-b87f-4a56-9078-5f4e3a2d1c8b"
VAR="/sys/firmware/efi/efivars/PvTryBoot-${GUID}"

# attributes: 0x07 = NV | BS_ACCESS | RT_ACCESS
# value: 0x01
printf '\x07\x00\x00\x00\x01' > "$VAR"
reboot
```

Pantavisor efiab.c wraps this in `efiab_flush_env()` — when `pv_try` is set,
it writes the PvTryBoot NV variable via efivarfs.

### PvBootPartition (volatile, set by stage 1)

Equivalent of RPi's `/proc/device-tree/chosen/bootloader/partition`.

Tells Linux which partition was actually booted.

- **Name:** `PvBootPartition`
- **Attributes:** `BS_ACCESS | RT_ACCESS` (NO `NV` — volatile, cleared on reboot)
- **Value:** ASCII partition number (e.g. `"2"` or `"3"`)

Reading from Linux:

```bash
GUID="a4e3e45c-b87f-4a56-9078-5f4e3a2d1c8b"
VAR="/sys/firmware/efi/efivars/PvBootPartition-${GUID}"
# skip 4-byte attributes prefix
dd if="$VAR" bs=1 skip=4 2>/dev/null
```

### PvBootTryBoot (volatile, set by stage 1)

Equivalent of RPi's `/proc/device-tree/chosen/bootloader/tryboot`.

Tells Linux whether this boot was a tryboot.

- **Name:** `PvBootTryBoot`
- **Attributes:** `BS_ACCESS | RT_ACCESS` (NO `NV` — volatile)
- **Value:** `"1"` if this was a tryboot, `"0"` if normal boot

Reading from Linux:

```bash
GUID="a4e3e45c-b87f-4a56-9078-5f4e3a2d1c8b"
VAR="/sys/firmware/efi/efivars/PvBootTryBoot-${GUID}"
dd if="$VAR" bs=1 skip=4 2>/dev/null
```

### Variable summary

| Variable         | Persistence | Set by     | Read by    | RPi equivalent |
|------------------|-------------|------------|------------|----------------|
| `PvTryBoot`      | NV (one-shot, deleted by stage 1) | Linux (efiab.c) | Stage 1 | `reboot "0 tryboot"` / PM_RSTS register |
| `PvBootPartition`| Volatile    | Stage 1    | Linux (efiab.c) | `/proc/device-tree/chosen/bootloader/partition` |
| `PvBootTryBoot`  | Volatile    | Stage 1    | Linux (efiab.c) | `/proc/device-tree/chosen/bootloader/tryboot` |

## Boot Flow (current implementation)

```
OVMF firmware
  → Loads EFI/BOOT/BOOTX64.EFI from ESP (stage 1)
    → Prints "pv-efi-boot stage1"
    → Reads autoboot.txt → boot_partition=2
    → Loads pvboot.efi from partition 2 (stage 2)
      → Prints "pv-efi-boot stage2"
      → Loads pv-linux.efi from same partition (UKI)
        → Kernel boots with embedded cmdline + initramfs
          → Pantavisor starts (/init)
            → efiab init: reads autoboot.txt via mcopy
            → Mounts storage (ext4 on /dev/sda4)
            → Starts containers (os, pvr-sdk)
            → Reaches STATE_WAIT → READY
```

Serial output sequence:
```
BdsDxe: loading Boot0001 "UEFI QEMU HARDDISK..."
pv-efi-boot stage1
Loading stage2...
pv-efi-boot stage2
Loading UKI...
[kernel boot messages]
Pantavisor starting...
Pantavisor (TM) (024-... | Pantavisor Remix Distro (021)) - pantavisor.io
```

### Boot Flow (planned — with EFI variables)

#### Stage 1 (ESP — BOOTX64.EFI, ~100-150 lines)

```
Stage 1 starts (loaded by firmware from ESP)
│
├─ 1. Read EFI variable "PvTryBoot"
│     ├─ Found (value == 0x01):
│     │   a. DELETE PvTryBoot immediately (one-shot)
│     │   b. is_tryboot = true
│     │
│     └─ Not found:
│         a. is_tryboot = false
│
├─ 2. Read /autoboot.txt from ESP
│     └─ Parse [all] section → get default boot_partition
│     └─ If is_tryboot: parse [tryboot] section → override boot_partition
│
├─ 3. Set volatile EFI variables for Linux
│     ├─ PvBootPartition = "<boot_partition>"
│     └─ PvBootTryBoot = is_tryboot ? "1" : "0"
│
├─ 4. Find target boot partition
│     └─ Enumerate handles with SIMPLE_FILE_SYSTEM_PROTOCOL
│     └─ Match device path Hard Drive node partition number
│         (works for both MBR and GPT — UEFI abstracts this)
│
├─ 5. Load stage 2 from target partition
│     └─ Open SIMPLE_FILE_SYSTEM → open /pvboot.efi
│     └─ LoadImage() → firmware measures into TPM PCR 4
│     └─ If Secure Boot: firmware verifies signature automatically
│
├─ 6. StartImage() → hand off to stage 2
│
└─ 7. If stage 2 load/start fails:
      ├─ If was tryboot → try the [all] boot_partition as fallback
      └─ If already fallback → print error, halt
```

#### Stage 2 (boot partition — pvboot.efi, ~80-100 lines)

```
Stage 2 starts (chainloaded by stage 1)
│
├─ 1. Open own filesystem
│     └─ LoadedImageProtocol->DeviceHandle → SIMPLE_FILE_SYSTEM_PROTOCOL
│
├─ 2. Load UKI
│     └─ Open /pv-linux.efi
│     └─ LoadImage() → firmware verifies signature + measures into TPM PCR 4
│
├─ 3. StartImage() → UKI boots
│     └─ EFI stub finds .cmdline, .linux, .initrd in its own PE sections
│     └─ Kernel boots with embedded cmdline and initrd
│
└─ 4. If UKI load fails → return error to stage 1
      (stage 1 can catch this and try fallback)
```

#### Note on stage 2 returning to stage 1

If stage 2's `LoadImage()` or `StartImage()` for the UKI fails, stage 2
returns. Since stage 2 was itself started via `StartImage()` from stage 1,
control goes back to stage 1 which can then attempt fallback.

If the kernel boots but then panics, control does NOT return. The watchdog /
reboot cycle handles that recovery.

## Pantavisor efiab Bootloader

The `efiab.c` module (~700 lines) implements `struct bl_ops` modeled on `rpiab.c`:

| Operation | Implementation |
|-----------|---------------|
| init | Mount efivarfs, read autoboot.txt from ESP via mcopy |
| get/set/unset env | efiab.txt key=value storage (same format as rpiab.txt) |
| flush env | Write efiab.txt; if `pv_try` set, write PvTryBoot NV var |
| install_update | Copy efiboot.img to try partition, write pv_rev.txt |
| commit_update | Flip autoboot.txt (swap boot/try partitions) |
| validate_state | Check pv_rev.txt matches expected revision |

Runtime dependency: `mtools` (for mcopy FAT access without mounting).

## Rollback Scenarios

### Happy path: update succeeds

```
Pantavisor userspace (running from slot A, partition 2):
  1. Mount pvboot-b (partition 3)
  2. Write new pvboot.efi (stage 2) and pv-linux.efi (UKI)
  3. Unmount pvboot-b
  4. Set EFI variable PvTryBoot = 0x01
  5. reboot

Stage 1:
  1. Read PvTryBoot → set → delete it, is_tryboot = true
  2. Read autoboot.txt → [all] boot_partition=2, [tryboot] boot_partition=3
  3. is_tryboot → use partition 3
  4. Set PvBootPartition="3", PvBootTryBoot="1"
  5. Chainload /pvboot.efi from partition 3
  6. Stage 2 loads /pv-linux.efi → kernel boots

New revision running:
  1. Pantavisor reads PvBootTryBoot → "1" (we're in tryboot)
  2. Pantavisor reads PvBootPartition → "3" (booted from partition 3)
  3. Pantavisor validates system health
  4. Commit: flip autoboot.txt →
       [all] boot_partition=3
       [tryboot] boot_partition=2
  → Done. Next normal reboot boots partition 3.
```

### Failure: new revision kernel panics / hangs

```
Pantavisor userspace:
  1. Set PvTryBoot = 0x01
  2. reboot

Stage 1:
  1. Read PvTryBoot → set → DELETE it (now gone)
  2. Boot partition 3 (tryboot)

Partition 3 boots → kernel panic / hang / watchdog fires

Power cycle or watchdog reboot:
  Stage 1:
    1. Read PvTryBoot → NOT FOUND (was deleted last boot)
    2. Read autoboot.txt → [all] boot_partition=2
    3. Boot partition 2 (known good) → system recovered
```

### Failure: UKI or stage 2 not found on try partition

```
Stage 1:
  1. Read PvTryBoot → set → delete it
  2. Try to load /pvboot.efi from partition 3 → EFI_NOT_FOUND
  3. IMMEDIATE FALLBACK: load from partition 2 instead
  4. Set PvBootTryBoot="0" (this is not a tryboot anymore)
  → System boots safely from known-good slot
```

### Failure: UKI signature invalid on try partition

```
Stage 1:
  1. Chainloads stage 2 from partition 3 (stage 2 signature OK)

Stage 2:
  1. LoadImage("/pv-linux.efi") → EFI_SECURITY_VIOLATION
  2. Return error to stage 1

Stage 1:
  1. Catches error from stage 2
  2. Falls back to partition 2 → boots known-good UKI
```

## TPM Measurement Chain

Using standard UEFI LoadImage/StartImage throughout means the firmware's
TCG implementation automatically measures every loaded image:

```
PCR 4 (Boot Manager Code):
  extend: pvboot.efi (stage 1)     ← firmware measures at boot
  extend: pvboot.efi (stage 2)     ← stage 1 calls LoadImage
  extend: pv-linux.efi (UKI)      ← stage 2 calls LoadImage
                                      (covers kernel + initrd + cmdline
                                       as one measurement)

PCR 5 (Boot Manager Configuration):
  extend: GPT/MBR partition entries
  extend: boot variables
```

Accessible from Linux via:
- `/sys/kernel/security/tpm0/binary_bios_measurements` (event log)
- `tpm2_pcrread` for final PCR values

The full event log shows which stage 2 and which UKI were loaded, from which
partition. The cmdline is part of the measured artifact, so remote attestation
can verify exactly which command line was used.

No GRUB in the chain means no measurement gaps or inconsistencies.

## Secure Boot / Signing

Each `.efi` binary is independently signed. UEFI firmware enforces signature
verification at every `LoadImage()` call when Secure Boot is enabled.

```
Firmware Secure Boot (PK → KEK → db)
  │
  ├─ Verifies pvboot.efi (stage 1)    ← signed, frozen, never changes
  │
  ├─ Verifies pvboot.efi (stage 2)    ← signed, per-slot, updateable
  │
  └─ Verifies pv-linux.efi (UKI)     ← signed, per-slot, updateable
                                         (covers kernel + initrd + cmdline)
```

If a signature doesn't verify, `LoadImage()` returns `EFI_SECURITY_VIOLATION`.
Stage 1 or stage 2 catches this and falls back to the other slot.

### Signing options

**Option A — Own keys (fleet devices):**
- Generate Pantavisor PK/KEK/db key hierarchy
- Sign all .efi binaries with your key
- Enroll on target hardware at provisioning time
- Full chain of trust under your control

**Option B — Microsoft shim (off-the-shelf hardware):**
- Ship shim.efi signed by Microsoft's third-party CA
- Shim verifies stage 1 against embedded MOK
- Stage 1 verifies stage 2, stage 2 verifies UKI (via firmware db + MOK)
- Works on any laptop with default Secure Boot keys

**Option C — Both:**
- Shim for generic hardware, own keys for fleet
- Stage 1 on ESP could be shim itself, which chainloads the real stage 1

### Key rotation

Since stage 2 and the UKI live on A/B partitions, signing keys can be rotated
as part of a normal update. Ship new binaries signed with new key, enroll new
key, commit slot. If enrollment fails → tryboot rolls back → old binaries with
old key still work.

## QEMU Testing

```bash
# Interactive (Ctrl-A X to quit)
./scripts/run-qemu-efi.sh

# With timeout
./scripts/run-qemu-efi.sh --timeout 60

# Automated diagnostics
expect scripts/qemu-diag.exp "lxc-ls -f" "pvcontrol ls" "pventer -c os id"
```

QEMU uses `-cpu IvyBridge` to match the core2-64 tune (avoids "Illegal instruction"
crashes in Alpine container binaries).

See `TESTPLAN-EFI.md` for full executable test plan.

### TPM testing with swtpm

```bash
# Terminal 1: start TPM emulator
mkdir -p /tmp/tpm
swtpm socket --tpmstate dir=/tmp/tpm \
  --ctrl type=unixio,path=/tmp/tpm/sock --tpm2

# Terminal 2: QEMU with TPM
qemu-system-x86_64 \
  -bios ovmf.fd \
  -chardev socket,id=chrtpm,path=/tmp/tpm/sock \
  -tpmdev emulator,id=tpm0,chardev=chrtpm \
  -device tpm-tis,tpmdev=tpm0 \
  -drive file=test-disk.img,format=raw \
  -m 1024 -serial stdio

# Inside booted Linux:
tpm2_pcrread sha256:4    # verify measurement chain
```

### What can be tested in QEMU

- Stage 1 reading autoboot.txt and chainloading stage 2 ✓
- Stage 2 loading UKI and booting Linux ✓
- PvTryBoot EFI variable set/read/delete cycle (planned)
- PvBootPartition / PvBootTryBoot volatile variables readable from Linux (planned)
- Fallback when UKI or stage 2 missing on try partition (planned)
- Fallback on signature verification failure (Secure Boot mode) (planned)
- Full A/B flip cycle: tryboot → boot → commit → reboot (planned)
- MBR and GPT partition layouts (different disk images)
- TPM measurements (with swtpm emulator) (planned)

### What needs real hardware

- Firmware quirks (non-standard partition handling, NVRAM limits)
- MBR-on-UEFI behavior across different firmware vendors
- Actual Secure Boot with enrolled keys
- Performance / boot time measurements

## Mapping to RPi tryboot

| RPi                                                  | pv-efi-boot x86                          |
|------------------------------------------------------|------------------------------------------|
| `autoboot.txt` on first FAT partition                | `autoboot.txt` on ESP (partition 1)       |
| `[all]` / `[tryboot]` sections                       | Identical syntax                          |
| `tryboot_a_b=1`                                      | Identical                                 |
| `boot_partition=N`                                   | Identical (partition number)              |
| `reboot "0 tryboot"` (sets PM_RSTS register)         | Set `PvTryBoot` NV EFI variable + reboot  |
| Tryboot flag auto-cleared (one-shot in hardware)     | `PvTryBoot` deleted by stage 1 (one-shot) |
| `/proc/device-tree/chosen/bootloader/partition`      | `PvBootPartition` volatile EFI variable   |
| `/proc/device-tree/chosen/bootloader/tryboot`        | `PvBootTryBoot` volatile EFI variable     |
| RPi firmware reads FAT, loads kernel                 | Stage 1 reads FAT, chainloads stage 2     |
| Single firmware image (not updateable via A/B)       | Stage 1 frozen; stage 2 updateable per-slot |
| boot.img + boot.sig (RPi secure boot)                | Signed .efi binaries (UEFI Secure Boot)   |
| kernel.img + initramfs + cmdline.txt (separate)      | pv-linux.efi UKI (all bundled, all signed) |
| `rpiab.c` / `rpiab.txt`                             | `efiab.c` / `efiab.txt`                  |
| `rpiboot.img`                                        | `efiboot.img`                             |

## Source Structure (pv-efi-boot)

```
pv-efi-boot/
├── Makefile                 ← gnu-efi build, produces stage1.efi and stage2.efi
├── src/
│   ├── stage1/
│   │   └── main.c           ← ~100-150 lines
│   ├── stage2/
│   │   └── main.c           ← ~80-100 lines
│   └── common/
│       ├── pvboot.h          ← shared constants (GUIDs, variable names, paths)
│       ├── autoboot.h/.c    ← INI-style parser for autoboot.txt
│       ├── partfind.h/.c    ← find partition by number via device path
│       └── efivar.h/.c      ← EFI variable read/write/delete helpers
```

## Module Responsibilities

### common/pvboot.h
- `PV_VENDOR_GUID` definition
- Variable name strings (`PvTryBoot`, `PvBootPartition`, `PvBootTryBoot`)
- File paths (`/autoboot.txt`, `/pvboot.efi`, `/pv-linux.efi`)
- Any shared constants

### common/autoboot.c (~80 lines)
- Read file from SIMPLE_FILE_SYSTEM_PROTOCOL handle
- Parse INI-style sections: `[all]`, `[tryboot]`
- Extract `boot_partition` and `tryboot_a_b` values
- If tryboot active and `[tryboot]` section present, override values
- Returns struct { int boot_partition; int tryboot_a_b; }

### common/partfind.c (~60 lines)
- `LocateHandleBuffer()` for all `EFI_SIMPLE_FILE_SYSTEM_PROTOCOL` handles
- For each handle, get device path via `DEVICE_PATH_PROTOCOL`
- Walk device path nodes, find `MEDIA_HARDDRIVE_DP` node
- Check `PartitionNumber` field (1-based, works for MBR and GPT)
- Return the handle matching the requested partition number
- No dependency on partition table type — UEFI firmware already parsed it

### common/efivar.c (~50 lines)
- `pv_read_clear_tryboot()` — GetVariable PvTryBoot + DeleteVariable
- `pv_set_boot_info()` — SetVariable for PvBootPartition and PvBootTryBoot
  (volatile, BS+RT access)

### stage1/main.c (~100-150 lines)
- Call `pv_read_clear_tryboot()` → determine is_tryboot
- Open own filesystem (ESP), read `/autoboot.txt`
- Call autoboot parser with is_tryboot flag
- Call `pv_set_boot_info()` to set volatile variables for Linux
- Call `pv_find_partition(boot_partition)` → get filesystem handle
- Open `/pvboot.efi` on target partition
- `LoadImage()` / `StartImage()`
- On failure: if was tryboot, retry with [all] partition; else halt

### stage2/main.c (~80-100 lines)
- Open own filesystem via `LoadedImageProtocol->DeviceHandle`
- Open `/pv-linux.efi` (UKI)
- `LoadImage()` → firmware verifies + measures
- `StartImage()` → kernel boots with embedded cmdline + initrd
- On failure → return, control goes back to stage 1

## Pantavisor Userspace Integration

The Pantavisor init/daemon needs platform-specific code for x86 EFI tryboot,
equivalent to what exists for RPi. The abstraction is:

```c
// Platform interface (pseudo-code)
struct pv_bootloader {
    int  (*get_booted_partition)(void);
    bool (*is_tryboot)(void);
    int  (*set_tryboot)(void);
    int  (*commit)(int partition);
};
```

### x86 EFI implementation (efiab.c — implemented)

```
get_booted_partition():
    read /sys/firmware/efi/efivars/PvBootPartition-{GUID}
    (fallback: parse autoboot.txt from ESP via mcopy)
    return partition number

is_tryboot():
    read /sys/firmware/efi/efivars/PvBootTryBoot-{GUID}
    (fallback: always false when variable absent)
    return value == "1"

set_tryboot():
    write PvTryBoot = 0x01 to /sys/firmware/efi/efivars/PvTryBoot-{GUID}
    return 0

commit(partition):
    write autoboot.txt to ESP via mcopy:
      [all]
      tryboot_a_b=1
      boot_partition=<partition>

      [tryboot]
      boot_partition=<other partition>
    return 0
```

### RPi implementation (existing, for comparison)

```
get_booted_partition():
    read /proc/device-tree/chosen/bootloader/partition

is_tryboot():
    read /proc/device-tree/chosen/bootloader/tryboot

set_tryboot():
    reboot "0 tryboot"   (or vcmailbox)

commit(partition):
    write autoboot.txt on boot partition
```

### Deploying updates

```
deploy_update(new_uki_path, new_stage2_path):
    other_partition = (current_partition == 2) ? 3 : 2
    mount other_partition
    copy new_stage2_path → /pvboot.efi
    copy new_uki_path    → /pv-linux.efi
    unmount other_partition
    set_tryboot()
    reboot
```

## Build & Yocto Integration

All dependencies are in oe-core scarthgap. No meta-oe or other layers needed.

### Dependencies (all in oe-core scarthgap)

| Component      | Recipe            | Purpose                          |
|----------------|-------------------|----------------------------------|
| gnu-efi        | `gnu-efi`         | EFI headers, crt0, libraries     |
| gcc + binutils | (native)          | Cross-compiler, objcopy          |
| EFI stub       | `linux-kernel`    | linuxx64.efi.stub for UKI        |
| ukify          | `systemd`         | UKI assembly tool (optional, can use objcopy) |
| sbsigntools    | `sbsigntool` (meta-oe) | Signing (optional, only for Secure Boot) |
| OVMF           | `ovmf`            | QEMU testing firmware            |

## Open Items

### Implementation (near-term)

1. **EFI variable communication**: Stage 1 should set PvBootPartition and
   PvBootTryBoot volatile variables so efiab.c can read boot state directly
   instead of re-parsing autoboot.txt.

2. **Tryboot cycle**: End-to-end test of PvTryBoot write → reboot → stage1
   reads/deletes → boots try partition → pantavisor commits/rollback.

3. **A/B update test**: Install efiboot.img to try partition via dd, write
   pv_rev.txt, flip autoboot.txt, verify new revision boots.

4. **`pv_rev.txt` on factory boot**: First boot has no pv_rev.txt on boot_a.
   The `mcopy: File "::pv_rev.txt" not found` warning is harmless but efiab.c
   should handle this more gracefully.

### Design questions (longer-term)

5. **EFI stub source:** The UKI needs an EFI stub (`linuxx64.efi.stub`).
   Currently extracted from the kernel build. Confirm this is the right
   approach vs systemd-boot's stub.

6. **Partition numbering across disks:** `boot_partition=N` assumes all
   partitions are on the same disk. If ESP is on a different disk from boot
   partitions, partition discovery needs to be scoped to the correct disk.
   Simplest: match partitions on the same disk as the ESP (same parent device
   in device path).

7. **Watchdog:** Should stage 1 or stage 2 arm a hardware watchdog before
   booting via `SetWatchdogTimer()`? Would ensure automatic reboot if the
   kernel hangs before Pantavisor's own watchdog starts.

8. **Fallback UX:** Should stage 1 print a message during fallback, or boot
   silently? A brief "Tryboot failed, falling back" helps debugging.

9. **MBR testing:** Some firmware has quirky MBR-on-UEFI support. Need a
   test matrix of firmware vendors.

10. **UKI size:** With kernel + initramfs bundled, the UKI can be 30-100MB+.
    Current boot partitions are 128MB. Confirm this is sufficient.

11. **Per-device cmdline:** If any boot parameters need to be device-specific
    (serial numbers, MAC addresses, etc.), those cannot be in the signed UKI.
    Options: EFI variables, data partition config read by initramfs, or
    separate signed config UKI addon (Linux 6.x+ feature).

12. **Secure Boot signing**: Sign stage1, stage2, and UKI with test keys.
    Enroll in OVMF for QEMU testing.
